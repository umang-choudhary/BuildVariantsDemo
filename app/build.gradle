plugins {
    id 'com.android.application'
    id 'org.jetbrains.kotlin.android'
    id 'kotlin-android-extensions'
}

android {
    compileSdk 32

    defaultConfig {
        applicationId "com.icemobile"
        minSdk 26
        targetSdk 32
        versionCode 1
        versionName "1.0"

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
    }

    signingConfigs {
        release {
            storeFile file('C:\\Users\\UmangC\\AndroidProjects\\MiscLearningProjects\\BuildVariantsDemo\\build_variants.jks')
            storePassword 'Build@1234'
            keyAlias 'key_alias'
            keyPassword 'Build@1234'
        }
    }

    /*
    -> Build Variants are formed by Build Types and Product Flavors.
    1. Build Type applies different build and packaging settings.
       An example of build types are “Debug” and “Release”.
       -> the basic idea is that build types are for different builds of your application
       that aren't functionally different -- if you have a debug and release version of your app,
       they're the same app, but one contains debugging code, maybe more logging, etc.,
       and the other is streamlined and optimized and possibly obfuscated via ProGuard.
    2. Product Flavors specify different features and device requirements,
       such as custom source code, resources, and minimum API levels.
       -> With flavors, the intent is that the app is notably different in some way.
       The clearest example would be a free vs. a paid version of your app,
       but developers may also differentiate based on where it's being distributed
       (which could affect in-app billing API use).
    */
    buildTypes {
        buat {
            applicationIdSuffix ".buat"
            manifestPlaceholders = [app_name: "IceMobileBuat"]
            buildConfigField "String", 'BASE_URL', '"https://buat-myicebox.reddyice.com/HHUpgradeApi/"'
            resValue 'string', 'images_file_path', "Android/data/" + defaultConfig.applicationId + applicationIdSuffix + "/files/Pictures"
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
            signingConfig signingConfigs.release
        }
        buat2 {
            applicationIdSuffix ".buat2"
            manifestPlaceholders = [app_name: "IceMobileBuat2"]
            buildConfigField "String", 'BASE_URL', '"https://buat2-myicebox.reddyice.com/HHRedesignApi/"'
            resValue 'string', 'images_file_path', "Android/data/" + defaultConfig.applicationId + applicationIdSuffix + "/files/Pictures"
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
            signingConfig signingConfigs.release
        }
        production {
            applicationIdSuffix ".prod"
            manifestPlaceholders = [app_name: "IceMobile"]
            buildConfigField "String", 'BASE_URL', '"https://myicebox.reddyice.com/HHUpgradeApi/"'
            resValue 'string', 'images_file_path', "Android/data/" + defaultConfig.applicationId + applicationIdSuffix + "/files/Pictures"
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
            signingConfig signingConfigs.release
        }
    }

    /*
    Why Product Flavors?
         1. They address the issue of having separate project code for each version of the app
            while still having one project code.
         2. Given a scenario where you have a free and a paid app you can limit features in the free
            and expose all the other features in the paid version of the app.
         3. Given another scenario where you want to implement region-specific functions
            depending on the country, you can use product flavors for such a use case.
         4. White labeling (these are apps that are developed by a certain company,
            and they are re-branded and resold by other companies).
     */

    flavorDimensions "country"
    productFlavors {
        india {
            dimension "country"
            applicationIdSuffix ".india"
            manifestPlaceholders = [app_name_suffix: "Ind"]
            versionNameSuffix ".2"
        }
        america {
            dimension "country"
            applicationIdSuffix ".america"
            manifestPlaceholders = [app_name_suffix: "Usa"]
            versionNameSuffix ".0.2"
        }
        australia {
            dimension "country"
            applicationIdSuffix ".australia"
            manifestPlaceholders = [app_name_suffix: "Aus"]
        }
    }

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
    kotlinOptions {
        jvmTarget = '1.8'
    }
}

dependencies {

    implementation 'androidx.core:core-ktx:1.7.0'
    implementation 'androidx.appcompat:appcompat:1.4.1'
    implementation 'com.google.android.material:material:1.5.0'
    implementation 'androidx.constraintlayout:constraintlayout:2.1.3'
    testImplementation 'junit:junit:4.13.2'
    androidTestImplementation 'androidx.test.ext:junit:1.1.3'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.4.0'
    implementation 'androidx.activity:activity-ktx:1.4.0'

}